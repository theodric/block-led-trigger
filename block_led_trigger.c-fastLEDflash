// SPDX-License-Identifier: GPL-2.0
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/leds.h>
#include <linux/blkdev.h>
#include <linux/delay.h>
#include <linux/workqueue.h>
#include <linux/timer.h>
#include <linux/jiffies.h>
#include <linux/fs.h>

static bool invert_brightness;
module_param(invert_brightness, bool, 0444);
MODULE_PARM_DESC(invert_brightness, "Invert LED brightness");

static unsigned long blink_delay_ms = 10;
module_param(blink_delay_ms, ulong, 0644);
MODULE_PARM_DESC(blink_delay_ms, "Duration of LED blink in milliseconds");

static char *devices[8];
static int device_count;
module_param_array(devices, charp, &device_count, 0444);
MODULE_PARM_DESC(devices, "Block devices to monitor (e.g., sda,sdb)");

DEFINE_LED_TRIGGER(ledtrig_block);

static struct timer_list blink_timer;
static bool led_state = false;

static void blink_timer_callback(struct timer_list *t)
{
	led_state = !led_state;
	led_trigger_event(ledtrig_block, led_state ? LED_FULL : LED_OFF);
	
	if (led_state) {
		mod_timer(&blink_timer, jiffies + msecs_to_jiffies(blink_delay_ms));
	}
}

static void trigger_led_blink(void)
{
	if (!timer_pending(&blink_timer)) {
		led_state = true;
		led_trigger_event(ledtrig_block, LED_FULL);
		mod_timer(&blink_timer, jiffies + msecs_to_jiffies(blink_delay_ms));
	}
}

// Hook into the block layer by monitoring /proc/diskstats
static struct workqueue_struct *activity_wq;
static struct delayed_work activity_work;
static unsigned long last_read_ios = 0;
static unsigned long last_write_ios = 0;

static void check_disk_activity(struct work_struct *work)
{
	struct file *f;
	loff_t pos = 0;
	char buf[2048];
	ssize_t len;
	unsigned long current_read_ios = 0;
	unsigned long current_write_ios = 0;
	char *line, *saveptr;
	
	// Read /proc/diskstats to check for disk activity
	f = filp_open("/proc/diskstats", O_RDONLY, 0);
	if (!IS_ERR(f)) {
		len = kernel_read(f, buf, sizeof(buf) - 1, &pos);
		if (len > 0) {
			buf[len] = '\0';
			
			// Parse each line to find disk I/O
			line = strtok_r(buf, "\n", &saveptr);
			while (line) {
				unsigned long major, minor, rd_ios, wr_ios;
				char name[32];
				
				// Parse diskstats line: major minor name rd_ios rd_merged rd_sectors rd_ticks wr_ios wr_merged wr_sectors wr_ticks ...
				if (sscanf(line, "%lu %lu %31s %lu %*u %*u %*u %lu", 
				           &major, &minor, name, &rd_ios, &wr_ios) == 5) {
					// Skip partition entries (they have non-zero minor numbers)
					if (minor == 0) {
						current_read_ios += rd_ios;
						current_write_ios += wr_ios;
					}
				}
				line = strtok_r(NULL, "\n", &saveptr);
			}
		}
		filp_close(f, NULL);
	}
	
	// If we detect new I/O activity, trigger the LED
	if (current_read_ios > last_read_ios || current_write_ios > last_write_ios) {
		trigger_led_blink();
		last_read_ios = current_read_ios;
		last_write_ios = current_write_ios;
	}
	
	// Requeue the work to check again
	queue_delayed_work(activity_wq, &activity_work, msecs_to_jiffies(100));
}

static int __init block_led_trigger_init(void)
{
	pr_info("block_led_trigger: loading\n");

	// Register the LED trigger
	led_trigger_register_simple("block-activity", &ledtrig_block);
	
	// Initialize the blink timer
	timer_setup(&blink_timer, blink_timer_callback, 0);
	
	// Initialize the workqueue for activity monitoring
	activity_wq = create_singlethread_workqueue("block_led_activity");
	if (!activity_wq) {
		pr_err("block_led_trigger: failed to create workqueue\n");
		led_trigger_unregister_simple(ledtrig_block);
		return -ENOMEM;
	}
	
	INIT_DELAYED_WORK(&activity_work, check_disk_activity);
	queue_delayed_work(activity_wq, &activity_work, msecs_to_jiffies(50));

	pr_info("block_led_trigger loaded with disk activity monitoring!\n");
	pr_info("Use: echo block-activity > /sys/class/leds/YOUR_LED/trigger\n");
	return 0;
}

static void __exit block_led_trigger_exit(void)
{
	// Clean up workqueue
	if (activity_wq) {
		cancel_delayed_work_sync(&activity_work);
		destroy_workqueue(activity_wq);
	}
	
	// Clean up timer
	if (timer_pending(&blink_timer)) {
		timer_delete(&blink_timer);
	}
	
	led_trigger_unregister_simple(ledtrig_block);
	pr_info("block_led_trigger: unloaded\n");
}

module_init(block_led_trigger_init);
module_exit(block_led_trigger_exit);

MODULE_AUTHOR("your_mom");
MODULE_DESCRIPTION("LED trigger for block IO with activity monitoring");
MODULE_LICENSE("GPL");
